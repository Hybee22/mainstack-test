// Generated by CodiumAI

import Product from "../../../models/Product";
import { CreateProductType, UpdateProductType } from "../../../types";
import { ProductService } from "./product.service";

describe("ProductService", () => {
  // create a product successfully
  it("should create a product successfully when valid payload is provided", async () => {
    // Arrange
    const payload: CreateProductType = {
      name: "Product 1",
      description: "Description 1",
      price: 10,
      category: "Category 1",
    };
    const productRepositoryMock = {
      create: jest.fn().mockResolvedValue(payload),
    };
    //@ts-ignore
    const productService = new ProductService(productRepositoryMock as any);

    // Act
    const result = await productService.createProduct(payload);

    // Assert
    expect(result).toEqual(payload);
    expect(productRepositoryMock.create).toHaveBeenCalledWith(payload);
  });

  // get all categories successfully
  //   it("should get all categories successfully", async () => {
  //     // Arrange
  //     const products = [
  //       {
  //         name: "Product 1",
  //         description: "Description 1",
  //         price: 10,
  //         category: "Category 1",
  //       },
  //       {
  //         name: "Product 2",
  //         description: "Description 2",
  //         price: 20,
  //         category: "Category 2",
  //       },
  //     ];
  //     const productRepositoryMock = {
  //       find: jest.fn().mockResolvedValue(products),
  //     };
  //     //@ts-ignore
  //     const productService = new ProductService(productRepositoryMock as any);

  //     // Act
  //     const result = await productService.getCategories();

  //     // Assert
  //     expect(result).toEqual(products);
  //     expect(productRepositoryMock.find).toHaveBeenCalledWith({});
  //   });

  // Should return an array of products with populated category field
  it("should return an array of products with populated category field", async () => {
    const products = [
      {
        name: "Product 1",
        description: "Description 1",
        price: 10,
        category: "Category 1",
      },
      {
        name: "Product 2",
        description: "Description 2",
        price: 20,
        category: "Category 2",
      },
    ];
    const productRepositoryMock = {
      find: jest.fn().mockResolvedValue(products),
    };

    //@ts-ignore
    const productService = new ProductService(productRepositoryMock as any);

    jest.spyOn(Product, "populate").mockImplementation((data, options) => {
      return data.map((item: any) => {
        return { ...item, category: { name: "categoryName" } };
      });
    });

    const result = await productService.getProducts();

    expect(result).toBeDefined();
    expect(productRepositoryMock.find).toHaveBeenCalled();
    expect(Product.populate).toHaveBeenCalledWith(products, {
      path: "category",
    });
  });

  // update a product successfully
  it("should update a product successfully when valid id and data are provided", async () => {
    // Arrange
    const id = "123";
    const data: UpdateProductType = {
      name: "Updated Product",
      description: "Updated Description",
      price: 15,
      category: "Updated Category",
    };
    const updatedProduct = {
      _id: id,
      ...data,
    };
    const productRepositoryMock = {
      findByIdAndUpdate: jest.fn().mockResolvedValue(updatedProduct),
    };
    //@ts-ignore
    const productService = new ProductService(productRepositoryMock as any);

    // Act
    const result = await productService.updateProduct(id, data);

    // Assert
    expect(result).toEqual(updatedProduct);
    expect(productRepositoryMock.findByIdAndUpdate).toHaveBeenCalledWith(
      id,
      data,
      { new: true }
    );
  });

  // update a product with invalid id
  it("should throw an error when updating a product with invalid id", async () => {
    // Arrange
    const id = "123";
    const data: UpdateProductType = {
      name: "Updated Product",
      description: "Updated Description",
      price: 15,
      category: "Updated Category",
    };
    const productRepositoryMock = {
      findByIdAndUpdate: jest
        .fn()
        .mockRejectedValue(new Error("Something went wrong")),
    };
    //@ts-ignore
    const productService = new ProductService(productRepositoryMock as any);

    // Act & Assert
    await expect(productService.updateProduct(id, data)).rejects.toThrow();
  });

  // delete a product successfully
  it("should delete a product successfully when valid id is provided", async () => {
    // Arrange
    const id = "123456789";
    const productRepositoryMock = {
      findByIdAndDelete: jest.fn().mockResolvedValue(null),
    };
    //@ts-ignore
    const productService = new ProductService(productRepositoryMock as any);

    // Act
    const result = await productService.deleteProduct(id);

    // Assert
    expect(result).toBeNull();
    expect(productRepositoryMock.findByIdAndDelete).toHaveBeenCalledWith(id);
  });

  // get a product by id successfully
  it("should get a product by id successfully when valid id is provided", async () => {
    // Arrange
    const id = "12345";
    const product = {
      _id: id,
      name: "Product 1",
      description: "Description 1",
      price: 10,
      category: "Category 1",
    };
    const productRepositoryMock = {
      findById: jest.fn().mockResolvedValue(product),
    };
    //@ts-ignore
    const productService = new ProductService(productRepositoryMock as any);

    // Act
    const result = await productService.getProductById(id);

    // Assert
    expect(result).toEqual(product);
    expect(productRepositoryMock.findById).toHaveBeenCalledWith(id);
  });

  // Should return an array of products with the given category
  it("should return an array of products with the given category", async () => {
    // Arrange
    const category = "categoryId";
    const products = [
      { name: "Product 1", category: "electronics" },
      { name: "Product 2", category: "electronics" },
    ];
    const productRepositoryMock = {
      find: jest.fn().mockResolvedValue(products),
    };
    const productService = new ProductService(productRepositoryMock as any);

    // Act
    const result = await productService.getProductsByCategory(category);

    // Assert
    expect(result).toEqual(products);
    expect(productRepositoryMock.find).toHaveBeenCalledWith({ category });
  });
});
